* бэкенд генерирует замены по викитексту
* фронтенд находит замены по html
* предлагается отдать всю фильтрацию замен на фронтенд
* это будет работать, если все слова из викитекста будут в каком-то виде встречаться в html


Слова из викитекста, не встречающиеся в html (в виде TextNode):
* [x] комментарии
* [x] ссылки вида `[[link|name]]`, потому что в html встречается только `name`
* [x] Скрытые блоки `{{Начало скрытого блока}} ... {{Конец скрытого блока}}`
* [ ] имена файлов

Итак, 
* на бэкенде фильтруем только комментарии
* на фронтенде фильтруем всё остальное, то есть:
  * цитаты (тег `blockquote`)
  * Секции `литература`, `источники`, `ссылки` и другие
  * содержание (`#toc`)
  
---

* Раньше на бэкенде для каждого слова (`dword`) считалось число таких же слов (`numberSameDwords`), аналогично на клиенте, если числа не совпадали, то слово пропускается
* Утверждается, что не получится написать игнорирование слов так, чтобы количества всегда совпадали. Особенно для больших статей количества часто могут отличаться на единицу
* Предлагается отказаться от идеи считания числа слов в пользу концепции контекста
* То есть вместе с каждой заменой будет идти контекст слова, а именно несколько символов до него и несколько после
* На фронтенде замены будут сопоставляться html'у по этому контексту 
* А именно, контекст каждого найденного вхождения сравнивается с контекстом каждой замены, выбирается замена с наибольшим совпадением, если длина этого совпадения больше 10
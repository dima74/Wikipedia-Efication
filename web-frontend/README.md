# Warning
Данное README немного неактуальное (не соответствует итоговой реализации).

# Виды редакторов в Википедии

Существует две категории редакторов: визуальные и редакторы викитекста.

## Визуальный редактор
Существует в единственной версии. Википедия использует собственную реализация на основе `contenteditable="true"`.

## Редактор викитекста
Существует две версии, при этом каждая позволяет включать/отключать подсветку синтаксиса.

### Стандартный (возможно называется «редактор викитекста 2010»)
* Без подсветки синтаксиса используется просто `<textarea>`.
* С подсветкой синтаксиса используется редактор CodeMirror (https://codemirror.net/)

### Новый режим викитекста («редактор викитекста 2017»)
* Без подсветки синтаксиса используется собственная реализация Википедии на основе `contenteditable="true"`
* С подсветкой синтаксиса используется редактор CodeMirror

## Резюме
В итоге существуют следующие возможные места для запуска Скрипта-Ёфикатора:
1. Из самой статьи (без перехода в какой-либо режим редактирования)
2. Просто `<textarea>`
3. Редактор CodeMirror
4. Собственная реализация Википедии на основе `contenteditable="true"`

Скрипт-Ёфикатор будет поддерживать режимы {1, 2, 3}. Для режимов 2 и 3 просто реализовать полное (идеальное) сопоставление замен. Режим 1 уже реализован, но будет не рекомендоваться его использовать, так как в нём сопоставление замен работает не идеально.


# Реализация
Необходимы реализовать два нетривиальных действия:
1. Сопоставить замены (то есть список объектов вида `{ yoword: ..., wordStartIndex: ... }`) с конкретным текстом (словом) в конкретном dom-элементе
2. Подсветить каждую замену (background некоторого цвета, плюс некоторая дополнительная информация, например полоска сверху от слова, соответствующуя его частоте)

(*) Также очень хотелось бы, чтобы во время ёфикации можно было параллельно вносить небольшие изменения (например при обнаружении опечатки рядом с ёфицируемым словом).

## CodeMirror (#3)
CodeMirror предоставляет самый удобный, простой и надёжный интерфейс для сопоставления и выделения:
1. `cm.posFromIndex(wordStartIndex)`, `cm.posFromIndex(wordEndIndex)` → получаем координаты слова (в системе координат cm), которые можно использовать в (2)
2. `cm.markText( wordStartPos, wordEndPos, { className: '...' } )` → слово оборачивается в свой `<span class='...'>` 

(*) выполняем (1) и (2) для всех замен, но подсвечиваем только текущую замену, в конце делаем unMark

## Textarea (#2)
Ранее `<textarea>` рассматривалась как одна нода и применялся такой же подход как в #1. Однако это не позволяет реализовать (*), поэтому будет испробован следующий подход:
1&2: Заменяем `textarea` на `div contenteditable="true" style="white-space: pre">`, далее оборачиваем каждую замену в `<span class='...'>` (getRange по wordIndexStart + replaceRange)

## В самой статье (#1)
Уже реализован и поэтому будет продолжаться использоваться (хотя в идеале выпилить бы его) следующий не очень красивый и надёжный способ:
1. Используя `document.createTreeWalker` проходим по всем текстовым нодам, ищем ё-слова в тексте ноды, по контексту сопостовляем каждое ё-слово с некоторой заменой
2. Для каждой сопоставленной замены находим её позицию на странице и создаём соответствующий `<span style="position: absolute">`
